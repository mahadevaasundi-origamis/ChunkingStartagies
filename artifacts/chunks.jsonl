{"text": "Embedded Systems-18EC62\n\nAzdocuments.in\n\nEMBEDDED SYSTEMS\n\nCourse Code : 18EC62\n\nCIE Marks :40\n\nLecture Hours/Week : 03 + 2 (Tutorial)\n\nSEE marks :60\n\nTotal Number of Lecture Hours : 50 (10 Hrs / Module)\n\nExam Hours : 03\n\nCREDITS : 04\n\nMODULE -1 ARM-32 bit Microcontroller: Thumb-2 technology and applications of ARM,Architecture of ARM Cortex M3, Various Units in the architecture, Debuggingsupport, General Purpose Registers, Special Registers, exceptions, interrupts,stack operation, reset sequence (Text 1: Ch-l, 2, 3)\n\nARM -32-BIT MICROCONTROLLER\n\nAbout ARM Cortex-M3 PROCESSOR\n\nThe microcontroller market is vast, with more than 20 billion devices per year estimated to be shipped in\n\n2010. A bewildering array of vendors, devices, and architectures is competing in this market.", "tokens": 203, "start_char": 0, "end_char": 784, "metadata": {"doc_id": "doc", "chunk_id": "doc:narrative:0", "source_path": null, "mime_type": null, "page_number": null, "bbox": null, "section_title": null, "content_type": "narrative", "tokens": 203, "start_char": 0, "end_char": 784, "start_token": null, "end_token": null, "hash_sha256": "a278a759e7c2a78247a5264da36a8b564ef3699409195f705a2ca7d7466ffe21", "vector_metric": "cosine", "embedding_model": "nomic-embed-text:v1.5", "table_schema": null, "table_rows": null, "neighbors": null, "created_at": "2025-11-24T12:04:49.982006"}}
{"text": "The\n\nrequirement for higher performance microcontrollers has been driven globally by the industry’s changing\n\nneeds; for example, microcontrollers are required to handle more work without increasing a product’s\n\nfrequency or power. In addition, microcontrollers are becoming increasingly connected, whether by\n\nUniversal Serial Bus (USB), Ethernet, or wireless radio, and hence, the processing needed to support these\n\ncommunication channels and advanced peripherals are growing. The ARM Cortex™-M3 processor, the first of the Cortex generation of processors released by ARM in\n\n2006, was primarily designed to target the 32-bit microcontroller market. The Cortex- M3 processor\n\nprovides excellent performance at low gate count and comes with many new features previously available\n\nonly in high-end processors. The Cortex-M3 addresses the requirements for the 32-bit embedded processor\n\nmarket in the following ways:\n\n Greater performance efficiency: allowing more work to be done without increasing the frequency or\n\npower requirements\n\n Low power consumption: enabling longer battery life, especially critical in portable products\n\nincluding wireless networking applications.  Enhanced determinism: guaranteeing that critical tasks and interrupts are serviced as quickly\n\nwww.azdocuments.in\n\nPage 1\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nas possible and in a known number of cycles\n\n Improved code density: ensuring that code fits in even the smallest memory footprints\n\n Ease of use: providing easier programmability and debugging for the growing number of 8-bit and 16-\n\nbit users migrating to 32 bits\n\n Lower cost solutions: reducing 32-bit-based system costs close to those of legacy 8-bit and 16- bit\n\ndevices\n\n Wide choice of development tools: from low-cost or free compilers to full-featured development\n\nsuites from many development tool vendors. Brief History of ARM\n\nARM was formed in 1990 as Advanced RISC Machines Ltd., a joint venture of Apple Computer, Acorn\n\nComputer Group, and VLSI Technology. In 1991, ARM introduced the ARM6 processor family, and VLSI\n\nbecame the initial licensee. Subsequently, additional companies, including Texas Instruments, NEC, Sharp, and\n\nST Microelectronics, licensed the ARM processor designs, extending the applications of ARM processors into\n\nmobile phones, computer hard disks, personal digital assistants (PDAs), home entertainment systems, and many\n\nother consumer products. Architecture Versions\n\nOver the years, ARM has continued to develop new processors and system blocks. These include the\n\npopular ARM7TDMI processor and, more recently, the ARM1176TZ(F)-S processor, which is used in high-\n\nend applications such as smart phones. The evolution of features and enhancements to the processors over\n\ntime has led to successive versions of the ARM architecture. Note that architecture version numbers are\n\nindependent from processor names. For example, the ARM7TDMI processor is based on the ARMv4T\n\narchitecture (the T is for Thumb® instruction mode support). Over the past several years, ARM extended its product portfolio by diversifying its CPU development,\n\nwhich resulted in the architecture version 7 or v7. In this version, the architecture design is divided into three\n\nprofiles:\n\n A Profile (ARMv7-A): Application processors which are designed to handle complex\n\napplications such as high-end embedded operating systems (OSs) (e.g., Symbian, Linux, and\n\nWindows Embedded). These processors requiring the highest processing power, virtual memory\n\nsystem support with memory management units (MMUs), and, optionally, enhanced Java support\n\nand a secure program execution environment. Example products include high-end mobile phones and\n\nelectronic wallets for financial transactions.  R Profile (ARMv7-R): Real-time, high-performance processors targeted primarily at the higher end\n\nof the real-time1 market—those applications, such as high-end breaking systems and hard drive\n\nwww.azdocuments.in\n\nPage 2\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\ncontrollers, in which high processing power and high reliability are essential and for which low\n\nlatency is important.  M Profile (ARMv7-M): Processors targeting low-cost applications in which processing efficiency\n\nis important and cost, power consumption, low interrupt latency, and ease of use are critical, as well\n\nas industrial control applications, including real-time control systems. The Thumb-2 Technology and Instruction Set Architecture\n\nThe Thumb-23 technology extended the Thumb Instruction Set Architecture (ISA) into a highly\n\nefficient and powerful instruction set that delivers significant benefits in terms of ease of use, code\n\nsize, and performance (see Figure 1). The extended instruction set in Thumb-2 is a superset of the\n\nprevious 16-bit Thumb instruction set, with additional 16-bit instructions alongside 32-bit\n\ninstructions. It allows more complex operations to be carried out in the Thumb state, thus allowing\n\nhigher efficiency by reducing the number of states switching between ARM state and Thumb state. Fig.1.1 the Relationship between the Thumb Instructions Set in Thumb-2 Technology and the Traditional Thumb\n\nWith support for both 16-bit and 32-bit instructions in the Thumb-2 instruction set, there is no need to switch\n\nthe processor between Thumb state (16-bit instructions) and ARM state (32-bit instructions). For example, in\n\nARM7 or ARM9 family processors, you might need to switch to ARM state if you want to carry out\n\ncomplex calculations or a large number of conditional operations and good performance is needed, whereas\n\nin the Cortex-M3 processor, you can mix 32-bit instructions with 16-bit instructions without switching\n\nstate, getting high code density and high performance with no extra complexity. www.azdocuments.in\n\nPage 3\n\nEmbedded Systems-18EC62 Cortex-M3 Processor Applications\n\nAzdocuments.in\n\n Low-cost microcontrollers: The Cortex-M3 processor\n\nis\n\nideally\n\nsuited\n\nfor\n\nlow-cost\n\nmicrocontrollers, which are commonly used in consumer products, from toys to electrical appliances. It\n\nis a highly competitive market due to the many well-known 8-bit and 16-bit microcontroller products\n\non the market. Its lower power, high performance, and ease-of- use advantages enable embedded\n\ndevelopers to migrate to 32-bit systems and develop products with the ARM architecture.  Automotive: Another ideal application for the Cortex-M3 processor is in the automotive industry. The Cortex-M3 processor has very high-performance efficiency and low interrupt latency, allowing it\n\nto be used in real-time systems. The Cortex-M3 processor supports up to 240 external vectored\n\ninterrupts, with a built-in interrupt controller with nested interrupt supports and an optional MPU,\n\nmaking it ideal for highly integrated and cost-sensitive automotive applications.  Data communications: The processor’s low power and high efficiency, coupled with instructions\n\nin Thumb-2 for bit-field manipulation, make the Cortex-M3 ideal for many communications\n\napplications, such as Bluetooth and ZigBee.  Industrial control: In industrial control applications, simplicity, fast response, and reliability are\n\nkey factors. Again, the Cortex-M3 processors interrupt feature, low interrupt latency, and enhanced\n\nfault-handling features make it a strong candidate in this area.  Consumer products: In many consumer products, a high-performance microprocessor (or several\n\nof them) is used. The Cortex-M3 processor, being a small processor, is highly efficient and low in\n\npower and supports an MPU enabling complex software to execute while providing robust memory\n\nprotection. Architecture of ARM Corte M3\n\nThe Cortex™-M3 is a 32-bit microprocessor. It has a 32-bit data path, a 32-bit register bank, and\n\n32- bit memory interfaces (see Figure 2).", "tokens": 1614, "start_char": 784, "end_char": 8598, "metadata": {"doc_id": "doc", "chunk_id": "doc:narrative:1", "source_path": null, "mime_type": null, "page_number": null, "bbox": null, "section_title": null, "content_type": "narrative", "tokens": 1614, "start_char": 784, "end_char": 8598, "start_token": null, "end_token": null, "hash_sha256": "a6ccdf5a597dc51bb3b48aa11606a1971053a67a1d2e45c8c8602509e15d3180", "vector_metric": "cosine", "embedding_model": "nomic-embed-text:v1.5", "table_schema": null, "table_rows": null, "neighbors": null, "created_at": "2025-11-24T12:04:49.984283"}}
{"text": "The processor has a Harvard architecture, which means that it has a\n\nseparate instruction bus and data bus. This allows instructions and data accesses to take place at the same\n\ntime, and as a result of this, the performance of the processor increases because data accesses do not affect\n\nthe instruction pipeline. This feature results in multiple bus interfaces on Cortex-M3, each with optimized\n\nusage and the ability to be used simultaneously. However, the instruction and data buses share the same\n\nmemory space (a unified memory system). In other words, you cannot get 8 GB of memory space just\n\nbecause you have separate bus interfaces. www.azdocuments.in\n\nPage 4\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\n The Cortex-M3 processor is a 32-bit processor, with a 32-bit wide data path, register bank\n\nand memory interface. There are 13 general-purpose registers, two stack pointers, a link register, a\n\nprogram counter and a number of special registers including a program status register.", "tokens": 211, "start_char": 8598, "end_char": 9592, "metadata": {"doc_id": "doc", "chunk_id": "doc:narrative:2", "source_path": null, "mime_type": null, "page_number": null, "bbox": null, "section_title": null, "content_type": "narrative", "tokens": 211, "start_char": 8598, "end_char": 9592, "start_token": null, "end_token": null, "hash_sha256": "1da8338e26e70f1ca9c734e66bf98a26d93d082e1a92d905e93665b907ff0b86", "vector_metric": "cosine", "embedding_model": "nomic-embed-text:v1.5", "table_schema": null, "table_rows": null, "neighbors": null, "created_at": "2025-11-24T12:04:49.984283"}}
{"text": "Fig1.", "tokens": 3, "start_char": 9592, "end_char": 9597, "metadata": {"doc_id": "doc", "chunk_id": "doc:narrative:3", "source_path": null, "mime_type": null, "page_number": null, "bbox": null, "section_title": null, "content_type": "narrative", "tokens": 3, "start_char": 9592, "end_char": 9597, "start_token": null, "end_token": null, "hash_sha256": "073d9f0635c93b09c1fc7a26883b1479b5ec47f44a1e7d4bdf04d1455ac14fbf", "vector_metric": "cosine", "embedding_model": "nomic-embed-text:v1.5", "table_schema": null, "table_rows": null, "neighbors": null, "created_at": "2025-11-24T12:04:49.984283"}}
{"text": "2. A Simplified View of the CortexM3.  The Cortex-M3 core contains a decoder for traditional Thumb and new Thumb-2\n\ninstructions, an advanced ALU with support for hardware multiply and divide, control logic, and\n\ninterfaces to the other components of the processor.  The Cortex-M3 processor is a 32-bit processor, with a 32-bit wide data path, register bank and\n\nmemory interface. There are 13 general-purpose registers, two stack pointers, a link register, a program\n\ncounter and a number of special registers including a program status register.  The Cortex-M3 processor is a memory mapped system with a simple, fixed memory map for up to 4\n\ngigabytes of addressable memory space with predefined, dedicated addresses for code (code space),\n\nSRAM(memory space), external memories/devices and internal/external peripherals. There is also a\n\nspecial region to provide for vendor specific addressability. www.azdocuments.in\n\nPage 5\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\n\n\nThe MPU is an optional component of the Cortex-M3 processor that can improve the reliability\n\nof an embedded system by protecting critical data used by the operating system from user applications,\n\nseparating processing tasks by disallowing access to each other's data, disabling access to memory\n\nregions, allowing memory regions to be defined as read-only and detecting unexpected memory accesses\n\nthat could potentially break the system. \n\nThe highly configurable NVIC is an integral part of the Cortex-M3 processor and provides\n\nthe processor’s outstanding interrupt handling abilities. In its standard implementation it supplies a\n\nNonMaskable Interrupt (NMI) and 32 general purpose physical interrupts with 8 levels of pre-emption\n\npriority.", "tokens": 365, "start_char": 9597, "end_char": 11323, "metadata": {"doc_id": "doc", "chunk_id": "doc:narrative:4", "source_path": null, "mime_type": null, "page_number": null, "bbox": null, "section_title": null, "content_type": "narrative", "tokens": 365, "start_char": 9597, "end_char": 11323, "start_token": null, "end_token": null, "hash_sha256": "da1bcc1b33069626f99ae904aa6d431f297402e0f275c81148597d553a09a88f", "vector_metric": "cosine", "embedding_model": "nomic-embed-text:v1.5", "table_schema": null, "table_rows": null, "neighbors": null, "created_at": "2025-11-24T12:04:49.985290"}}
{"text": "It can be configured to anywhere between 1 and 240 physical interrupts with up to 256 levels of\n\npriority though simple synthesis choices. \n\nThe debug access into a Cortex-M3 processor based system is through the Debug Access Port\n\n(DAP) that can be implemented as either a Serial Wire Debug Port (SW-DP) for a two-pin (clock and data)\n\nInterface or a Serial Wire JTAG Debug Port (SWJ-DP) that enables either JTAG or SW protocol to be\n\nused. The SWJ-DP defaults to JTAG mode on power reset and can be made to switch protocols with a\n\nspecific control sequence provided by the external debug hardware. \n\nThe Cortex-M3 processor bus matrix connects the processor and debug interface to the external\n\nbuses; the 32-bit AMBA® AHB-Lite based ICode, DCode and System interfaces and the 32-bit AMBA\n\nAPB™ based Private Peripheral Bus (PPB). The bus matrix also implements unaligned data accesses and\n\nbit banding\n\nwww.azdocuments.in\n\nPage 6\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nRegisters in Cortex-M3 processor\n\nThe Cortex-M3 processor has registers R0 through R15. R13 (the stack pointer) is banked,\n\nwith only one copy of the R13 visible at a time. R0–R12: General-Purpose Registers R0–R12 are 32-bit general-purpose registers for data\n\noperations. Some 16-bit Thumb® instructions can only access a subset of these registers (low\n\nregisters, R0–R7). R13: Stack Pointers The Cortex-M3 contains two stack pointers (R13). They are banked so\n\nthat only one is visible at a time.", "tokens": 368, "start_char": 11323, "end_char": 12799, "metadata": {"doc_id": "doc", "chunk_id": "doc:narrative:5", "source_path": null, "mime_type": null, "page_number": null, "bbox": null, "section_title": null, "content_type": "narrative", "tokens": 368, "start_char": 11323, "end_char": 12799, "start_token": null, "end_token": null, "hash_sha256": "ef532ac9eb75e151cad9e22fd83e4e801986d471a8aec7d6d69918fe2568b5e9", "vector_metric": "cosine", "embedding_model": "nomic-embed-text:v1.5", "table_schema": null, "table_rows": null, "neighbors": null, "created_at": "2025-11-24T12:04:49.985818"}}
{"text": "The two stack pointers are as follows:\n\n1. Main Stack Pointer (MSP): The default stack pointer, used by the operating\n\nsystem (OS) kernel and exception handlers\n\n2. Process Stack Pointer (PSP): Used by user application code. R14: The Link Register When a subroutine is called, the return address is stored in the link register. R15: The Program Counter The program counter is the current program address. This register\n\ncan be written to control the program flow. Fig1.", "tokens": 103, "start_char": 12799, "end_char": 13268, "metadata": {"doc_id": "doc", "chunk_id": "doc:narrative:6", "source_path": null, "mime_type": null, "page_number": null, "bbox": null, "section_title": null, "content_type": "narrative", "tokens": 103, "start_char": 12799, "end_char": 13268, "start_token": null, "end_token": null, "hash_sha256": "4060715b169b74c1c4cc58aec0b4f13c3e913dd2a5fb73a26ea9a3fea9e8c68f", "vector_metric": "cosine", "embedding_model": "nomic-embed-text:v1.5", "table_schema": null, "table_rows": null, "neighbors": null, "created_at": "2025-11-24T12:04:49.985818"}}
{"text": "3. Registers in the Cortex-M3\n\nwww.azdocuments.in\n\nPage 7\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nStack Pointer R13\n\nR13 is the stack pointer (SP). In the Cortex-M3 processor, there are two SPs. This duality allows\n\ntwo separate stack memories to be set up. When using the register name R13, you can only\n\naccess the current SP; the other one is inaccessible unless you use special instructions to move to\n\nspecial register from general-purpose register (MSR) and move special register to general-\n\npurpose register (MRS). The two SPs are as follows:\n\nMain Stack Pointer (MSP) or SP_main in ARM documentation: This is the default SP; it is\n\nused by the operating system (OS) kernel, exception handlers, and all application codes that\n\nrequire privileged access. Process Stack Pointer (PSP) or SP_process in ARM documentation: This is used by the\n\nbase-level application code (when not running an exception handler). www.azdocuments.in\n\nPage 8\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nIn the Cortex-M3, the instructions for accessing stack memory are PUSH and POP. The assembly\n\nlanguage syntax is as follows (text after each semicolon [;] is a comment):\n\nPUSH {R0} ; R13=R13-4, then Memory[R13] = R0\n\nPOP {R0} ; R0 = Memory[R13], then R13 = R13 + 4\n\nLink Register R14:\n\nR14 is the link register (LR). Inside an assembly program, you can write it as either R14 or LR. LR is used to store the return program counter (PC) when a subroutine or function is called—for\n\nexample, when you’re using the branch and link (BL) instruction:\n\nProgram Counter R15:\n\nR15 is the PC. You can access it in assembler code by either R15 or PC.", "tokens": 407, "start_char": 13268, "end_char": 14894, "metadata": {"doc_id": "doc", "chunk_id": "doc:narrative:7", "source_path": null, "mime_type": null, "page_number": null, "bbox": null, "section_title": null, "content_type": "narrative", "tokens": 407, "start_char": 13268, "end_char": 14894, "start_token": null, "end_token": null, "hash_sha256": "f956a1b6cdbbcb09c16d157e84537cfb732bc50884b0b382a54a896e5414e458", "vector_metric": "cosine", "embedding_model": "nomic-embed-text:v1.5", "table_schema": null, "table_rows": null, "neighbors": null, "created_at": "2025-11-24T12:04:49.985818"}}
{"text": "Because of the pipelined nature\n\nof the Cortex-M3 processor, when you read this register, you will find that the value is different than the\n\nlocation of the executing instruction, normally by 4. 0x1000 : MOV R0, PC ; R0 = 0x1004\n\nIn other instructions like literal load (reading of a memory location related to current PC value),\n\nthe effective value of PC might not be instruction address plus 4 due to alignment in address\n\ncalculation. But the PC value is still at least 2 bytes ahead of the instruction address during\n\nexecution\n\nwww.azdocuments.in\n\nPage 9\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nSpecial Registers:\n\nThe Cortex-M3 processor also has a number of special registers. They\n\nare as follows:\n\nProgram Status registers (PSRs)\n\nInterrupt Mask registers (PRIMASK, FAULTMASK, and BASEPRI)\n\nControl register (CONTROL)\n\nSpecial registers can only be accessed via MSR and MRS instructions; they do not have memory\n\naddresses:\n\nThe Built-In Nested Vectored Interrupt Controller:\n\nThe Cortex-M3 processor includes an interrupt controller called the Nested Vectored Interrupt Controller\n\n(NVIC). It is closely coupled to the processor core and provides a number of features as follows:\n\nNested interrupt support •\n\nwww.azdocuments.in\n\nPage 10\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nVectored interrupt support\n\nDynamic priority changes support\n\nReduction of interrupt latency\n\nInterrupt masking\n\nNested Interrupt Support: The NVIC provides nested interrupt support. All the external interrupts\n\nand most of the system exceptions can be programmed to different priority levels. When an interrupt occurs,\n\nthe NVIC compares the priority of this interrupt to the current running priority level. If the priority of the new\n\ninterrupt is higher than the current level, the interrupt handler of the new interrupt will override the current\n\nrunning task. Vectored Interrupt Support: The Cortex-M3 processor has vectored interrupt support. When an\n\ninterrupt is accepted, the starting address of the interrupt service routine (ISR) is located from a vector table in\n\nmemory. There is no need to use software to determine and branch to the starting address of the ISR. Thus, it\n\ntakes less time to process the interrupt request. Dynamic Priority Changes Support: Priority levels of interrupts can be changed by software\n\nduring run time. Interrupts that are being serviced are blocked from further activation until the ISR is\n\ncompleted, so their priority can be changed without risk of accidental reentry. Reduction of Interrupt Latency: The Cortex-M3 processor also includes a number of advanced features to\n\nlower the interrupt latency. These include automatic saving and restoring some register contents, reducing\n\ndelay in switching from one ISR to another, and handling of late arrival interrupts\n\nInterrupt Masking: Interrupts and system exceptions can be masked based on their priority level\n\nor masked completely using\n\nthe\n\ninterrupt masking\n\nregisters BASEPRI, PRIMASK, and\n\nFAULTMASK. They can be used to ensure that time-critical tasks can be finished on time without being interrupt\n\nwww.azdocuments.in\n\nPage 11\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nThe Memory Map:\n\nThe Cortex-M3 has a predefined memory map. This allows the built-in peripherals, such as the\n\ninterrupt controller and the debug components, to be accessed by simple memory access\n\ninstructions. Thus, most system features are accessible in C program code. The predefined\n\nmemory map also allows the Cortex-M3 processor to be highly optimized for speed and ease of\n\nintegration in system-on-a-chip (SoC) designs. The Cortex-M3 design has an internal bus infrastructure optimized for this memory usage. In\n\naddition, the design allows these regions to be used differently. For example, data memory can\n\nstill be put into the CODE region, and program code can be executed from an external Random\n\nAccess Memory (RAM) region. www.azdocuments.in\n\nPage 12\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nThe Bus Interface:\n\nThere are several bus interfaces on the Cortex-M3 processor. They allow the Cortex-M3 to carry\n\ninstruction fetches and data accesses at the same time. The main bus interfaces are as follows:\n\nCode memory buses\n\nSystem bus\n\nPrivate peripheral bus\n\nThe code memory region access is carried out on the code memory buses, which physically\n\nconsist of two buses, one called I-Code and other called D-Code. These are optimized for\n\ninstruction fetches for best instruction execution speed. The system bus is used to access memory\n\nand peripherals. This provides access to the Static Random Access Memory (SRAM),\n\nperipherals, external RAM, external devices, and part of the system level memory regions. The Instruction Set:\n\nThe Cortex-M3 supports the Thumb-2 instruction set. This is one of the most important features\n\nof the Cortex-M3 processor because it allows 32-bit instructions and 16-bit instructions to be\n\nused together for high code density and high efficiency. It is flexible and powerful yet easy to\n\nuse. In previous ARM processors, the central processing unit (CPU) had two operation states: a 32-\n\nbit ARM state and a 16-bit Thumb state. In the ARM state, the instructions are 32 bits and can\n\nexecute all supported instructions with very high performance. In the Thumb state, the\n\ninstructions are 16 bits, so there is a much higher instruction code density, but the Thumb state\n\ndoes not have all the functionality of ARM instructions and may require more instructions to\n\ncomplete certain types of operations. www.azdocuments.in\n\nPage 13\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nThe Cortex-M3 processor has a number of advantages over traditional ARM processors, such as:\n\nNo state switching overhead, saving both execution time and instruction space\n\nNo need to separate ARM code and Thumb code source files, making software development\n\nand maintenance easier\n\nIt’s easier to get the best efficiency and performance, in turn making it easier to write\n\nsoftware, because there is no need to worry about switching code between ARM and Thumb\n\nto try to get the best density/performance. The Cortex-M3 processor has a number of interesting and powerful instructions. Here are a few\n\nexamples:\n\nUFBX, BFI, and BFC: Bit field extract, insert, and clear instructions\n\nUDIV and SDIV: Unsigned and signed divide instructions\n\nWFE, WFI, and SEV: Wait-For-Event, Wait-For-Interrupts, and Send-Event; these allow the\n\nprocessor to enter sleep mode and to handle task synchronization on multiprocessor systems\n\nMSR and MRS: Move to special register from general-purpose register and move special\n\nregister to general-purpose register; for access to the special registers. www.azdocuments.in\n\nPage 14\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nInterrupts and Exceptions:\n\nThe Cortex-M3 processor implements a new exception model, introduced in the ARMv7-M\n\narchitecture. This exception model differs from the traditional ARM exception model, enabling\n\nvery efficient exception handling. It has a number of system exception handling. It has a number\n\nof system exceptions plus a number of external Interrupt Request (IRQs) (external interrupt\n\ninputs). There is no fast interrupt (FIQ) (fast interrupt in ARM7/ARM9/ ARM10/ARM11) in the Cortex-\n\nM3; however, interrupt priority handling and nested interrupt support are now included in the\n\ninterrupt architecture. Therefore, it is easy to set up a system that supports nested interrupts (a\n\nhigher-priority interrupt can override or preempt a lower-priority interrupt handler) and that\n\nbehaves just like the FIQ in traditional ARM processors. www.azdocuments.in\n\nPage 15\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nDebugging Support:\n\nThe Cortex-M3 processor includes a number of debugging features, such as program execution\n\ncontrols, including halting and stepping, instruction breakpoints, data watchpoints, registers and\n\nmemory accesses, profiling, and traces. The debugging hardware of the Cortex-M3 processor is\n\nbased on the CoreSight™ architecture. Unlike traditional ARM processors, the CPU core itself does not have a Joint Test Action Group\n\n(JTAG) interface. Instead, a debug interface module is decoupled from the core, and a bus\n\ninterface called the Debug Access Port (DAP) is provided at the core level. Through this bus\n\ninterface, external debuggers can access control registers to debug hardware as well as system\n\nmemory, even when the processor is running. The control of this bus interface is carried out by a\n\nDebug Port (DP) device. The DPs currently available are the Serial-Wire JTAG Debug Port (SWJ-DP) (supports the\n\ntraditional JTAG protocol as well as the Serial-Wire protocol) or the SW-DP (supports the Serial-\n\nWire protocol only). A JTAG-DP module from the ARM CoreSight product family can also be\n\nused. Chip manufacturers can choose to attach one of these DP modules to provide the debug\n\ninterface. Chip manufacturers can also include an Embedded Trace Macrocell (ETM) to allow instruction\n\ntrace. Trace information is output via the Trace Port Interface Unit (TPIU), and the debug host\n\n(usually a Personal Computer [PC]) can then collect the executed instruction information via\n\nexternal trace capturing hardware. www.azdocuments.in\n\nPage 16\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nStack Memory Operations:\n\nIn the Cortex-M3, besides normal software-controlled stack PUSH and POP, the stack PUSH and\n\nPOP operations are also carried out automatically when entering or exiting an exception/interrupt\n\nhandler. In this section, we examine the software stack operations. Operation:\n\nIn general, stack operations are memory write or read operations, with the address specified by\n\nan SP. Data in registers is saved into stack memory by a PUSH operation and can be restored to\n\nregisters later by a POP operation. The SP is adjusted automatically in PUSH and POP so that\n\nmultiple data PUSH will not cause old stacked data to be erased. The function of the stack is to store register contents in memory so that they can be restored\n\nlater, after a processing task is completed. For normal uses, for each store (PUSH), there must be\n\na corresponding read (POP), and the address of the POP operation should match that of the\n\nPUSH operation. When PUSH/POP instructions are used, the SP is incremented/decremented\n\nautomatically. When program control returns to the main program, the R0–R2 contents are the\n\nsame as before. Notice the order of PUSH and POP: The POP order must be the reverse of PUSH. These\n\noperations can be simplified, thanks to PUSH and POP instructions allowing multiple load and\n\nstore. In this case, the ordering of a register POP is automatically reversed by the processor. You\n\ncan also combine RETURN with a POP operation. This is done by pushing the LR to the stack\n\nand popping it back to PC at the end of the subroutine.", "tokens": 2279, "start_char": 14894, "end_char": 25728, "metadata": {"doc_id": "doc", "chunk_id": "doc:narrative:8", "source_path": null, "mime_type": null, "page_number": null, "bbox": null, "section_title": null, "content_type": "narrative", "tokens": 2279, "start_char": 14894, "end_char": 25728, "start_token": null, "end_token": null, "hash_sha256": "888fe0ec6be8d47ff2685a83dffc29d12ca31238b2915d03767736d16ae9a2ed", "vector_metric": "cosine", "embedding_model": "nomic-embed-text:v1.5", "table_schema": null, "table_rows": null, "neighbors": null, "created_at": "2025-11-24T12:04:49.986540"}}
{"text": "Cortex-M3 Stack Implementation:\n\nwww.azdocuments.in\n\nPage 17\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\n1. 16 Reset Sequence\n\nAfter the processor exits reset, it will read two words from memory\n\nAddress 0x00000000: Starting value of R13 (the SP)\n\nAddress 0x00000004: Reset vector (the starting address of program execution; LSB should be set to 1 to indicate Thumb state)\n\nThis differs from traditional ARM processor behavior. Previous ARM processors executed program code starting from address 0x0. Furthermore, the vector table in previous ARM devices was instructions. Figure 3.Reset sequence\n\nwww.azdocuments.in\n\nPage 18\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nFigure.4 Initial Stack Pointer Value and Initial Program Counter Value Example. In the Cortex-M3, the initial value for the MSP is put at the beginning of the memory map,\n\nfollowed by the vector table, which contains vector address values. (The vector table can be\n\nrelocated to another location later, during program execution.) In addition, the contents of the\n\nvector table are address values not branch instructions. The first vector in the vector table\n\n(exception type 1) is the reset vector, which is the second piece of data fetched by the processor\n\nafter reset. Because the stack operation in the Cortex-M3 is a full descending stack (SP\n\ndecrement before store), the initial SP value should be set to the first memory after the top of the\n\nstack region. For example, if you have a stack memory range from 0x20007C00 to 0x20007FFF\n\n(1 KB), the initial stack value should be set to 0x20008000. www.azdocuments.in\n\nPage 19\n\nEmbedded Systems-18EC62\n\nAzdocuments.in\n\nRecommended Questions\n\n1. Briefly discuss how Cortex-M3 address the requirements of the 32-bit embedded processor\n\nmarket\n\n2. Briefly explain the Thumb-2 technology and its advantages over thumb instruction set with\n\nrelevat diagram. 3.", "tokens": 434, "start_char": 25728, "end_char": 27603, "metadata": {"doc_id": "doc", "chunk_id": "doc:narrative:9", "source_path": null, "mime_type": null, "page_number": null, "bbox": null, "section_title": null, "content_type": "narrative", "tokens": 434, "start_char": 25728, "end_char": 27603, "start_token": null, "end_token": null, "hash_sha256": "b91b3ad2bfa8dd9866b67ea5559d1ca696dfb2610ca86284f2f0d6c416d8d5ec", "vector_metric": "cosine", "embedding_model": "nomic-embed-text:v1.5", "table_schema": null, "table_rows": null, "neighbors": null, "created_at": "2025-11-24T12:04:49.986540"}}
{"text": "Write a short note on the applicatios of Cortex-M3\n\n4. With a neat diagram, explain the architecture of ARM cortex M3 microcontroller. 5. What are the various registers in ARM Cortex M3? Specify the function of each of them. 6. Briefly describe the Special Register of ARM cortex M3. 7. Briefly explain about the operation modes and levels with relevant diagrams in case of ARM\n\nCortex-M3\n\n8. Explain the features of Nested vector Interrupt controller of ARM cortex M3. 9. With neat diagram explain the predefined memory map of ARM Cortex-M3\n\n10. Write a short note on a) Bus interface b) Memory Protection units of ARM cortex M3. 11. Describe the interrupts and exceptions supported by ARM Cortex M3. 12. Describe the debugging support in ARM Cortex M3. 13. Explain the stack operations using PUSH and POP instructions in ARM Cortex M3. 14. With relevant diagrams explain the reset sequence in ARM cortex M3. www.azdocuments.in\n\nPage 20", "tokens": 220, "start_char": 27603, "end_char": 28540, "metadata": {"doc_id": "doc", "chunk_id": "doc:narrative:10", "source_path": null, "mime_type": null, "page_number": null, "bbox": null, "section_title": null, "content_type": "narrative", "tokens": 220, "start_char": 27603, "end_char": 28540, "start_token": null, "end_token": null, "hash_sha256": "d7be79d65874c55c862aeb5fc3a30c4203f8a5dd66095278949684acac6f8fc3", "vector_metric": "cosine", "embedding_model": "nomic-embed-text:v1.5", "table_schema": null, "table_rows": null, "neighbors": null, "created_at": "2025-11-24T12:04:49.986540"}}
