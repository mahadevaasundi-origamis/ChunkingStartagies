[
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_1_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::1",
    "content": "Embedded Systems-18EC62 Azdocuments.in www.azdocuments.in Page 1\n\nEMBEDDED SYSTEMS\n\u2022 Course Code : 18EC62\n\u2022 CIE Marks :40\n\u2022 Lecture Hours/Week : 03 + 2 (Tutorial)\n\u2022 SEE marks :60\n\u2022 Total Number of Lecture Hours : 50 (10 Hrs / Module)\n\u2022 Exam Hours : 03\n\u2022 CREDITS : 04",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_1_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 1,
      "bbox": null,
      "section_title": "Embedded Systems",
      "chunk_summary": "Overview of embedded systems course details and module structure.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 266,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_1_1"
      ],
      "created_at": "2025-11-26T10:37:07.112453"
    },
    "page_number": 1,
    "token_count": 266
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_1_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::1",
    "content": "MODULE -1\nARM-32 bit Microcontroller: Thumb-2 technology and applications of ARM, Architecture of ARM Cortex M3, Various Units in the architecture, Debugging support, General Purpose Registers, Special Registers, exceptions, interrupts, stack operation, reset sequence (Text 1: Ch-l, 2, 3)",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_1_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 1,
      "bbox": null,
      "section_title": "Module 1: ARM-32 bit Microcontroller",
      "chunk_summary": "Introduction to ARM Cortex-M3 architecture, features, and applications.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 289,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_1_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_1_2"
      ],
      "created_at": "2025-11-26T10:37:07.112453"
    },
    "page_number": 1,
    "token_count": 289
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_1_2",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::1",
    "content": "ARM -32-BIT MICROCONTROLLER\n\nAbout ARM Cortex-M3 PROCESSOR\nThe microcontroller market is vast, with more than 20 billion devices per year estimated to be shipped in 2010. A bewildering array of vendors, devices, and architectures is competing in this market. The requirement for higher performance microcontrollers has been driven globally by the industry\u2019s changing needs; for example, microcontrollers are required to handle more work without increasing a product\u2019s frequency or power. In addition, microcontrollers are becoming increasingly connected, whether by Universal Serial Bus (USB), Ethernet, or wireless radio, and hence, the processing needed to support these communication channels and advanced peripherals are growing.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_1_2",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 1,
      "bbox": null,
      "section_title": "About ARM Cortex-M3 Processor",
      "chunk_summary": "Overview of the ARM Cortex-M3 microcontroller market and its features.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 733,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_1_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_2_0"
      ],
      "created_at": "2025-11-26T10:37:07.112453"
    },
    "page_number": 1,
    "token_count": 733
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_2_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::2",
    "content": "Embedded Systems-18EC62 Azdocuments.in www.azdocuments.in Page 2 as possible and in a known number of cycles Improved code density: ensuring that code fits in even the smallest memory footprints Ease of use: providing easier programmability and debugging for the growing number of 8-bit and 16-bit users migrating to 32 bits Lower cost solutions: reducing 32-bit-based system costs close to those of legacy 8-bit and 16-bit devices Wide choice of development tools: from low-cost or free compilers to full-featured development suites from many development tool vendors.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_2_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 2,
      "bbox": null,
      "section_title": "Introduction to Embedded Systems",
      "chunk_summary": "Overview of key features and benefits of embedded systems.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 569,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_1_2",
        "ES_Mod1@AzDOCUMENTS2.pdf_2_1"
      ],
      "created_at": "2025-11-26T10:37:11.415423"
    },
    "page_number": 2,
    "token_count": 569
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_2_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::2",
    "content": "Brief History of ARM ARM was formed in 1990 as Advanced RISC Machines Ltd., a joint venture of Apple Computer, Acorn Computer Group, and VLSI Technology. In 1991, ARM introduced the ARM6 processor family, and VLSI became the initial licensee. Subsequently, additional companies, including Texas Instruments, NEC, Sharp, and ST Microelectronics, licensed the ARM processor designs, extending the applications of ARM processors into mobile phones, computer hard disks, personal digital assistants (PDAs), home entertainment systems, and many other consumer products.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_2_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 2,
      "bbox": null,
      "section_title": "Brief History of ARM",
      "chunk_summary": "Historical development and licensing of ARM processors.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 564,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_2_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_2_2"
      ],
      "created_at": "2025-11-26T10:37:11.415423"
    },
    "page_number": 2,
    "token_count": 564
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_2_2",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::2",
    "content": "Architecture Versions Over the years, ARM has continued to develop new processors and system blocks. These include the popular ARM7TDMI processor and, more recently, the ARM1176TZ(F)-S processor, which is used in high-end applications such as smart phones. The evolution of features and enhancements to the processors over time has led to successive versions of the ARM architecture. Note that architecture version numbers are independent from processor names. For example, the ARM7TDMI processor is based on the ARMv4T architecture (the T is for Thumb\u00ae instruction mode support). Over the past several years, ARM extended its product portfolio by diversifying its CPU development, which resulted in the architecture version 7 or v7. In this version, the architecture design is divided into three profiles:",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_2_2",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 2,
      "bbox": null,
      "section_title": "Architecture Versions",
      "chunk_summary": "Development and diversification of ARM architecture versions.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 806,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_2_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_2_3"
      ],
      "created_at": "2025-11-26T10:37:11.415423"
    },
    "page_number": 2,
    "token_count": 806
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_2_3",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::2",
    "content": "\u2022 A Profile (ARMv7-A): Application processors which are designed to handle complex applications such as high-end embedded operating systems (OSs) (e.g., Symbian, Linux, and Windows Embedded). These processors requiring the highest processing power, virtual memory system support with memory management units (MMUs), and, optionally, enhanced Java support and a secure program execution environment. Example products include high-end mobile phones and electronic wallets for financial transactions.\n\u2022 R Profile (ARMv7-R): Real-time, high-performance processors targeted primarily at the higher end of the real-time market\u2014those applications, such as high-end breaking systems and hard drive",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_2_3",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 2,
      "bbox": null,
      "section_title": "ARM Architecture Profiles",
      "chunk_summary": "Different profiles within ARMv7 architecture for various applications.",
      "chunk_type": "bullet_list",
      "content_type": "markdown",
      "token_count": 689,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_2_2",
        "ES_Mod1@AzDOCUMENTS2.pdf_3_0"
      ],
      "created_at": "2025-11-26T10:37:11.415423"
    },
    "page_number": 2,
    "token_count": 689
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_3_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::3",
    "content": "Embedded Systems-18EC62 Azdocuments.in www.azdocuments.in Page 3 controllers, in which high processing power and high reliability are essential and for which low latency is important.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_3_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 3,
      "bbox": null,
      "section_title": "Embedded Systems Overview",
      "chunk_summary": "Introduction to embedded systems and processor profiles.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 183,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_2_3",
        "ES_Mod1@AzDOCUMENTS2.pdf_3_1"
      ],
      "created_at": "2025-11-26T10:37:14.894695"
    },
    "page_number": 3,
    "token_count": 183
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_3_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::3",
    "content": "M Profile (ARMv7-M): Processors targeting low-cost applications in which processing efficiency is important and cost, power consumption, low interrupt latency, and ease of use are critical, as well as industrial control applications, including real-time control systems.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_3_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 3,
      "bbox": null,
      "section_title": "Processor Profiles",
      "chunk_summary": "Description of ARM processor profiles targeting different applications.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 270,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_3_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_3_2"
      ],
      "created_at": "2025-11-26T10:37:14.894695"
    },
    "page_number": 3,
    "token_count": 270
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_3_2",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::3",
    "content": "The Thumb-23 technology extended the Thumb Instruction Set Architecture (ISA) into a highly efficient and powerful instruction set that delivers significant benefits in terms of ease of use, code size, and performance (see Figure 1). The extended instruction set in Thumb-2 is a superset of the previous 16-bit Thumb instruction set, with additional 16-bit instructions alongside 32-bit instructions. It allows more complex operations to be carried out in the Thumb state, thus allowing higher efficiency by reducing the number of states switching between ARM state and Thumb state.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_3_2",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 3,
      "bbox": null,
      "section_title": "Thumb-2 Technology and Instruction Set Architecture",
      "chunk_summary": "Overview of Thumb-2 technology and its benefits in instruction set architecture.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 582,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_3_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_3_3"
      ],
      "created_at": "2025-11-26T10:37:14.896743"
    },
    "page_number": 3,
    "token_count": 582
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_3_3",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::3",
    "content": "<table><tr><th>Instruction Set</th><th>Description</th></tr><tr><td>Thumb-2</td><td>Supports both 16-bit and 32-bit instructions, enabling complex operations without switching states.</td></tr><tr><td>Traditional Thumb</td><td>Uses only 16-bit instructions, requiring state switches for complex calculations.</td></tr></table>",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_3_3",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 3,
      "bbox": null,
      "section_title": "Relationship between Thumb Instructions in Thumb-2 and Traditional Thumb",
      "chunk_summary": "Comparison of instruction sets in Thumb-2 technology and traditional Thumb.",
      "chunk_type": "table",
      "content_type": "tabular",
      "token_count": 326,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_3_2",
        "ES_Mod1@AzDOCUMENTS2.pdf_3_4"
      ],
      "created_at": "2025-11-26T10:37:14.896743"
    },
    "page_number": 3,
    "token_count": 326
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_3_4",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::3",
    "content": "With support for both 16-bit and 32-bit instructions in the Thumb-2 instruction set, there is no need to switch the processor between Thumb state (16-bit instructions) and ARM state (32-bit instructions). For example, in ARM7 or ARM9 family processors, you might need to switch to ARM state if you want to carry out complex calculations or a large number of conditional operations and good performance is needed, whereas in the Cortex-M3 processor, you can mix 32-bit instructions with 16-bit instructions without switching state, getting high code density and high performance with no extra complexity.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_3_4",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 3,
      "bbox": null,
      "section_title": "Advantages of Thumb-2",
      "chunk_summary": "Benefits of Thumb-2 instruction set in processor performance and efficiency.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 603,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_3_3",
        "ES_Mod1@AzDOCUMENTS2.pdf_4_0"
      ],
      "created_at": "2025-11-26T10:37:14.896743"
    },
    "page_number": 3,
    "token_count": 603
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_4_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::4",
    "content": "The Cortex-M3 processor is used in various fields due to its low cost, high performance, and efficiency. It is suitable for low-cost microcontrollers in consumer products, automotive systems, data communications, industrial control, and consumer electronics. Its features enable migration to 32-bit systems and support real-time, embedded applications with high reliability and low power consumption.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_4_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 4,
      "bbox": null,
      "section_title": "Cortex-M3 Processor Applications",
      "chunk_summary": "Overview of various applications for the Cortex-M3 processor.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 400,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_3_4",
        "ES_Mod1@AzDOCUMENTS2.pdf_4_1"
      ],
      "created_at": "2025-11-26T10:37:17.966719"
    },
    "page_number": 4,
    "token_count": 400
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_4_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::4",
    "content": "\u2022 Low-cost microcontrollers: Used in consumer products, toys, and appliances, enabling migration to 32-bit ARM architecture.\n\u2022 Automotive: Suitable for real-time automotive systems with high-performance efficiency and low interrupt latency.\n\u2022 Data communications: Ideal for Bluetooth, ZigBee, and other communication protocols due to low power and instruction efficiency.\n\u2022 Industrial control: Suitable for applications requiring fast response, reliability, and fault handling.\n\u2022 Consumer products: Supports complex software with robust memory protection in small, efficient processors.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_4_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 4,
      "bbox": null,
      "section_title": "Applications of Cortex-M3",
      "chunk_summary": "Key application areas for the Cortex-M3 processor.",
      "chunk_type": "bullet_list",
      "content_type": "markdown",
      "token_count": 586,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_4_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_4_2"
      ],
      "created_at": "2025-11-26T10:37:17.966719"
    },
    "page_number": 4,
    "token_count": 586
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_4_2",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::4",
    "content": "The Cortex-M3 is a 32-bit microprocessor featuring a 32-bit data path, register bank, and memory interfaces. It employs a Harvard architecture with separate instruction and data buses, allowing simultaneous access to instructions and data, which enhances performance. Despite separate bus interfaces, the instruction and data buses share the same memory space, limiting total addressable memory to less than 8 GB.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_4_2",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 4,
      "bbox": null,
      "section_title": "Architecture of ARM Cortex-M3",
      "chunk_summary": "Details of the ARM Cortex-M3 microprocessor architecture.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 413,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_4_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_4_3"
      ],
      "created_at": "2025-11-26T10:37:17.966719"
    },
    "page_number": 4,
    "token_count": 413
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_4_3",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::4",
    "content": "<table>\n<tr><th>Feature</th><th>Description</th></tr>\n<tr><td>Data Path</td><td>32-bit</td></tr>\n<tr><td>Register Bank</td><td>32-bit</td></tr>\n<tr><td>Memory Interface</td><td>32-bit</td></tr>\n<tr><td>Architecture Type</td><td>Harvard architecture with separate instruction and data buses</td></tr>\n<tr><td>Memory Space</td><td>Shared between instruction and data buses, limited to less than 8 GB</td></tr>\n<tr><td>Bus Interfaces</td><td>Multiple, optimized for simultaneous use</td></tr>\n</table>",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_4_3",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 4,
      "bbox": null,
      "section_title": "Cortex-M3 Architecture Details",
      "chunk_summary": "Summary of key architectural features of Cortex-M3.",
      "chunk_type": "table",
      "content_type": "tabular",
      "token_count": 498,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_4_2",
        "ES_Mod1@AzDOCUMENTS2.pdf_5_0"
      ],
      "created_at": "2025-11-26T10:37:17.969778"
    },
    "page_number": 4,
    "token_count": 498
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_5_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::5",
    "content": "The Cortex-M3 processor is a 32-bit processor, with a 32-bit wide data path, register bank and memory interface. There are 13 general-purpose registers, two stack pointers, a link register, a program counter and a number of special registers including a program status register.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_5_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 5,
      "bbox": null,
      "section_title": "Embedded Systems Overview",
      "chunk_summary": "Introduction to the Cortex-M3 processor architecture and features.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 278,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_4_3",
        "ES_Mod1@AzDOCUMENTS2.pdf_5_1"
      ],
      "created_at": "2025-11-26T10:37:20.015178"
    },
    "page_number": 5,
    "token_count": 278
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_5_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::5",
    "content": "<figure> <img src='Fig1. 2. A Simplified View of the CortexM3.' alt='Simplified View of Cortex-M3'> </figure>",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_5_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 5,
      "bbox": null,
      "section_title": "Embedded Systems Overview",
      "chunk_summary": "Simplified diagram of the Cortex-M3 processor.",
      "chunk_type": "figure",
      "content_type": "narrative",
      "token_count": 109,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_5_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_5_2"
      ],
      "created_at": "2025-11-26T10:37:20.015178"
    },
    "page_number": 5,
    "token_count": 109
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_5_2",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::5",
    "content": "The Cortex-M3 core contains a decoder for traditional Thumb and new Thumb-2 instructions, an advanced ALU with support for hardware multiply and divide, control logic, and interfaces to the other components of the processor.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_5_2",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 5,
      "bbox": null,
      "section_title": "Cortex-M3 Instruction Support",
      "chunk_summary": "Details on instruction decoding and ALU features of Cortex-M3.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 224,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_5_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_5_3"
      ],
      "created_at": "2025-11-26T10:37:20.015178"
    },
    "page_number": 5,
    "token_count": 224
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_5_3",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::5",
    "content": "The Cortex-M3 processor is a memory mapped system with a simple, fixed memory map for up to 4 gigabytes of addressable memory space with predefined, dedicated addresses for code (code space), SRAM (memory space), external memories/devices and internal/external peripherals. There is also a special region to provide for vendor specific addressability.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_5_3",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 5,
      "bbox": null,
      "section_title": "Processor Architecture and Memory Map",
      "chunk_summary": "Description of the memory architecture and addressability of Cortex-M3.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 351,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_5_2",
        "ES_Mod1@AzDOCUMENTS2.pdf_6_0"
      ],
      "created_at": "2025-11-26T10:37:20.015178"
    },
    "page_number": 5,
    "token_count": 351
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_6_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::6",
    "content": "The MPU is an optional component of the Cortex-M3 processor that can improve the reliability of an embedded system by protecting critical data used by the operating system from user applications, separating processing tasks by disallowing access to each other's data, disabling access to memory regions, allowing memory regions to be defined as read-only and detecting unexpected memory accesses that could potentially break the system.\n\nThe highly configurable NVIC is an integral part of the Cortex-M3 processor and provides the processor\u2019s outstanding interrupt handling abilities. In its standard implementation it supplies a NonMaskable Interrupt (NMI) and 32 general purpose physical interrupts with 8 levels of pre-emption priority. It can be configured to anywhere between 1 and 240 physical interrupts with up to 256 levels of priority though simple synthesis choices.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_6_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 6,
      "bbox": null,
      "section_title": "Embedded Systems Overview",
      "chunk_summary": "Introduction to key components of the Cortex-M3 processor system.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 877,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_5_3",
        "ES_Mod1@AzDOCUMENTS2.pdf_6_1"
      ],
      "created_at": "2025-11-26T10:37:22.576656"
    },
    "page_number": 6,
    "token_count": 877
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_6_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::6",
    "content": "The debug access into a Cortex-M3 processor based system is through the Debug Access Port (DAP) that can be implemented as either a Serial Wire Debug Port (SW-DP) for a two-pin (clock and data) Interface or a Serial Wire JTAG Debug Port (SWJ-DP) that enables either JTAG or SW protocol to be used. The SWJ-DP defaults to JTAG mode on power reset and can be made to switch protocols with a specific control sequence provided by the external debug hardware.\n\nThe Cortex-M3 processor bus matrix connects the processor and debug interface to the external buses; the 32-bit AMBA\u00ae AHB-Lite based ICode, DCode and System interfaces and the 32-bit AMBA APB\u2122 based Private Peripheral Bus (PPB). The bus matrix also implements unaligned data accesses and bit banding.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_6_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 6,
      "bbox": null,
      "section_title": "Debug Access and Bus Matrix",
      "chunk_summary": "Details on debug access ports and the processor bus matrix in Cortex-M3.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 757,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_6_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_7_0"
      ],
      "created_at": "2025-11-26T10:37:22.576656"
    },
    "page_number": 6,
    "token_count": 757
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_7_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::7",
    "content": "The Cortex-M3 processor has registers R0 through R15. R13 (the stack pointer) is banked, with only one copy of the R13 visible at a time. R0\u2013R12: General-Purpose Registers R0\u2013R12 are 32-bit general-purpose registers for data operations. Some 16-bit Thumb\u00ae instructions can only access a subset of these registers (low registers, R0\u2013R7). R13: Stack Pointers The Cortex-M3 contains two stack pointers (R13). They are banked so that only one is visible at a time. The two stack pointers are as follows: 1. Main Stack Pointer (MSP): The default stack pointer, used by the operating system (OS) kernel and exception handlers 2. Process Stack Pointer (PSP): Used by user application code. R14: The Link Register When a subroutine is called, the return address is stored in the link register. R15: The Program Counter The program counter is the current program address. This register can be written to control the program flow.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_7_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 7,
      "bbox": null,
      "section_title": "Registers in Cortex-M3 processor",
      "chunk_summary": "Overview of the register set in the Cortex-M3 processor.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 920,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_6_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_7_1"
      ],
      "created_at": "2025-11-26T10:37:24.538576"
    },
    "page_number": 7,
    "token_count": 920
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_7_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::7",
    "content": "Fig1. 3. Registers in the Cortex-M3",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_7_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 7,
      "bbox": null,
      "section_title": "Registers in Cortex-M3 processor",
      "chunk_summary": "Additional details about the register functions and diagram reference.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 35,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_7_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_8_0"
      ],
      "created_at": "2025-11-26T10:37:24.538576"
    },
    "page_number": 7,
    "token_count": 35
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_8_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::8",
    "content": "R13 is the stack pointer (SP). In the Cortex-M3 processor, there are two SPs. This duality allows two separate stack memories to be set up. When using the register name R13, you can only access the current SP; the other one is inaccessible unless you use special instructions to move to special register from general-purpose register (MSR) and move special register to general-purpose register (MRS). The two SPs are as follows:",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_8_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 8,
      "bbox": null,
      "section_title": "Stack Pointer R13",
      "chunk_summary": "Overview of R13 as the stack pointer in Cortex-M3, including its duality and access methods.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 428,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_7_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_8_1"
      ],
      "created_at": "2025-11-26T10:37:27.054784"
    },
    "page_number": 8,
    "token_count": 428
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_8_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::8",
    "content": "\u2022 Main Stack Pointer (MSP) or SP_main in ARM documentation: This is the default SP; it is used by the operating system (OS) kernel, exception handlers, and all application codes that require privileged access.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_8_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 8,
      "bbox": null,
      "section_title": "Main Stack Pointer (MSP)",
      "chunk_summary": "Description of MSP as the default stack pointer used by privileged code and exception handlers.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 209,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_8_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_8_2"
      ],
      "created_at": "2025-11-26T10:37:27.054784"
    },
    "page_number": 8,
    "token_count": 209
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_8_2",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::8",
    "content": "\u2022 Process Stack Pointer (PSP) or SP_process in ARM documentation: This is used by the base-level application code (when not running an exception handler).",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_8_2",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 8,
      "bbox": null,
      "section_title": "Process Stack Pointer (PSP)",
      "chunk_summary": "Description of PSP used by application code when not handling exceptions.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 154,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_8_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_9_0"
      ],
      "created_at": "2025-11-26T10:37:27.054784"
    },
    "page_number": 8,
    "token_count": 154
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_9_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::9",
    "content": "In the Cortex-M3, the instructions for accessing stack memory are PUSH and POP. The assembly language syntax is as follows (text after each semicolon [;] is a comment): PUSH {R0} ; R13=R13-4, then Memory[R13] = R0 POP {R0} ; R0 = Memory[R13], then R13 = R13 + 4 Link Register R14: R14 is the link register (LR). Inside an assembly program, you can write it as either R14 or LR. LR is used to store the return program counter (PC) when a subroutine or function is called\u2014for example, when you\u2019re using the branch and link (BL) instruction.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_9_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 9,
      "bbox": null,
      "section_title": "Embedded Systems - Cortex-M3 Instruction Access",
      "chunk_summary": "Overview of stack memory access instructions and register usage in Cortex-M3.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 538,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_8_2",
        "ES_Mod1@AzDOCUMENTS2.pdf_9_1"
      ],
      "created_at": "2025-11-26T10:37:29.436907"
    },
    "page_number": 9,
    "token_count": 538
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_9_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::9",
    "content": "Program Counter R15: R15 is the PC. You can access it in assembler code by either R15 or PC. Because of the pipelined nature of the Cortex-M3 processor, when you read this register, you will find that the value is different than the location of the executing instruction, normally by 4. 0x1000 : MOV R0, PC ; R0 = 0x1004 In other instructions like literal load (reading of a memory location related to current PC value), the effective value of PC might not be instruction address plus 4 due to alignment in address calculation. But the PC value is still at least 2 bytes ahead of the instruction address during execution.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_9_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 9,
      "bbox": null,
      "section_title": "Program Counter (R15) in Cortex-M3",
      "chunk_summary": "Details about accessing and understanding the PC register in Cortex-M3 assembly.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 621,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_9_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_10_0"
      ],
      "created_at": "2025-11-26T10:37:29.436907"
    },
    "page_number": 9,
    "token_count": 621
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_10_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::10",
    "content": "The Cortex-M3 processor also has a number of special registers. They are as follows:",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_10_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 10,
      "bbox": null,
      "section_title": "Embedded Systems-18EC62",
      "chunk_summary": "Introduction to special registers in the Cortex-M3 processor.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 84,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_9_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_10_1"
      ],
      "created_at": "2025-11-26T10:37:31.893150"
    },
    "page_number": 10,
    "token_count": 84
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_10_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::10",
    "content": "\u2022 Program Status registers (PSRs)\n\u2022 Interrupt Mask registers (PRIMASK, FAULTMASK, and BASEPRI)\n\u2022 Control register (CONTROL)",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_10_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 10,
      "bbox": null,
      "section_title": "Embedded Systems-18EC62",
      "chunk_summary": "List of special registers in the Cortex-M3 processor.",
      "chunk_type": "bullet_list",
      "content_type": "markdown",
      "token_count": 123,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_10_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_10_2"
      ],
      "created_at": "2025-11-26T10:37:31.893150"
    },
    "page_number": 10,
    "token_count": 123
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_10_2",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::10",
    "content": "Special registers can only be accessed via MSR and MRS instructions; they do not have memory addresses:",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_10_2",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 10,
      "bbox": null,
      "section_title": "Embedded Systems-18EC62",
      "chunk_summary": "Access methods for special registers.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 103,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_10_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_10_3"
      ],
      "created_at": "2025-11-26T10:37:31.893150"
    },
    "page_number": 10,
    "token_count": 103
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_10_3",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::10",
    "content": "The Built-In Nested Vectored Interrupt Controller: The Cortex-M3 processor includes an interrupt controller called the Nested Vectored Interrupt Controller (NVIC). It is closely coupled to the processor core and provides a number of features as follows:",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_10_3",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 10,
      "bbox": null,
      "section_title": "Embedded Systems-18EC62",
      "chunk_summary": "Introduction to the Nested Vectored Interrupt Controller (NVIC).",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 253,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_10_2",
        "ES_Mod1@AzDOCUMENTS2.pdf_10_4"
      ],
      "created_at": "2025-11-26T10:37:31.893150"
    },
    "page_number": 10,
    "token_count": 253
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_10_4",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::10",
    "content": "Nested interrupt support",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_10_4",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 10,
      "bbox": null,
      "section_title": "Embedded Systems-18EC62",
      "chunk_summary": "Features of the NVIC, including nested interrupt support.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 24,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_10_3",
        "ES_Mod1@AzDOCUMENTS2.pdf_11_0"
      ],
      "created_at": "2025-11-26T10:37:31.893150"
    },
    "page_number": 10,
    "token_count": 24
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_11_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::11",
    "content": "The NVIC provides nested interrupt support. All the external interrupts and most of the system exceptions can be programmed to different priority levels. When an interrupt occurs, the NVIC compares the priority of this interrupt to the current running priority level. If the priority of the new interrupt is higher than the current level, the interrupt handler of the new interrupt will override the current running task.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_11_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 11,
      "bbox": null,
      "section_title": "Embedded Systems - Interrupt Support Features",
      "chunk_summary": "Overview of NVIC's nested interrupt support and priority management features.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 421,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_10_4",
        "ES_Mod1@AzDOCUMENTS2.pdf_11_1"
      ],
      "created_at": "2025-11-26T10:37:35.169512"
    },
    "page_number": 11,
    "token_count": 421
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_11_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::11",
    "content": "The Cortex-M3 processor has vectored interrupt support. When an interrupt is accepted, the starting address of the interrupt service routine (ISR) is located from a vector table in memory. There is no need to use software to determine and branch to the starting address of the ISR. Thus, it takes less time to process the interrupt request.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_11_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 11,
      "bbox": null,
      "section_title": "Vectored Interrupt Support",
      "chunk_summary": "Description of the Cortex-M3's vectored interrupt mechanism.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 340,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_11_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_11_2"
      ],
      "created_at": "2025-11-26T10:37:35.169512"
    },
    "page_number": 11,
    "token_count": 340
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_11_2",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::11",
    "content": "Priority levels of interrupts can be changed by software during run time. Interrupts that are being serviced are blocked from further activation until the ISR is completed, so their priority can be changed without risk of accidental reentry.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_11_2",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 11,
      "bbox": null,
      "section_title": "Dynamic Priority Changes",
      "chunk_summary": "Ability to change interrupt priorities during runtime safely.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 241,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_11_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_11_3"
      ],
      "created_at": "2025-11-26T10:37:35.171716"
    },
    "page_number": 11,
    "token_count": 241
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_11_3",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::11",
    "content": "The Cortex-M3 processor also includes a number of advanced features to lower the interrupt latency. These include automatic saving and restoring some register contents, reducing delay in switching from one ISR to another, and handling of late arrival interrupts.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_11_3",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 11,
      "bbox": null,
      "section_title": "Reduction of Interrupt Latency",
      "chunk_summary": "Features to minimize delay in interrupt handling.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 262,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_11_2",
        "ES_Mod1@AzDOCUMENTS2.pdf_11_4"
      ],
      "created_at": "2025-11-26T10:37:35.171716"
    },
    "page_number": 11,
    "token_count": 262
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_11_4",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::11",
    "content": "Interrupts and system exceptions can be masked based on their priority level or masked completely using the interrupt masking registers BASEPRI, PRIMASK, and FAULTMASK. They can be used to ensure that time-critical tasks can be finished on time without being interrupted.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_11_4",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 11,
      "bbox": null,
      "section_title": "Interrupt Masking",
      "chunk_summary": "Methods to mask interrupts and exceptions based on priority.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 271,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_11_3",
        "ES_Mod1@AzDOCUMENTS2.pdf_12_0"
      ],
      "created_at": "2025-11-26T10:37:35.171716"
    },
    "page_number": 11,
    "token_count": 271
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_12_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::12",
    "content": "The Memory Map:\n\nThe Cortex-M3 has a predefined memory map. This allows the built-in peripherals, such as the interrupt controller and the debug components, to be accessed by simple memory access instructions. Thus, most system features are accessible in C program code. The predefined memory map also allows the Cortex-M3 processor to be highly optimized for speed and ease of integration in system-on-a-chip (SoC) designs.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_12_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 12,
      "bbox": null,
      "section_title": "Embedded Systems-18EC62",
      "chunk_summary": "Introduction to the memory map of Cortex-M3.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 424,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_11_4",
        "ES_Mod1@AzDOCUMENTS2.pdf_12_1"
      ],
      "created_at": "2025-11-26T10:37:37.007991"
    },
    "page_number": 12,
    "token_count": 424
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_12_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::12",
    "content": "The Cortex-M3 design has an internal bus infrastructure optimized for this memory usage. In addition, the design allows these regions to be used differently. For example, data memory can still be put into the CODE region, and program code can be executed from an external Random Access Memory (RAM) region.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_12_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 12,
      "bbox": null,
      "section_title": "Embedded Systems-18EC62",
      "chunk_summary": "Details on Cortex-M3 internal bus infrastructure and memory usage.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 306,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_12_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_13_0"
      ],
      "created_at": "2025-11-26T10:37:37.007991"
    },
    "page_number": 12,
    "token_count": 306
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_13_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::13",
    "content": "The page discusses the Cortex-M3 processor, focusing on its bus interfaces and instruction set. It explains the different bus types, including code memory buses, system bus, and private peripheral bus, and their roles in instruction fetches and data access. The code memory buses consist of I-Code and D-Code, optimized for instruction fetches. The system bus accesses memory and peripherals such as SRAM, external RAM, and external devices.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_13_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 13,
      "bbox": null,
      "section_title": "Embedded Systems Overview",
      "chunk_summary": "Introduction to the Cortex-M3 processor and its bus interfaces.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 441,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_12_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_13_1"
      ],
      "created_at": "2025-11-26T10:37:39.778512"
    },
    "page_number": 13,
    "token_count": 441
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_13_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::13",
    "content": "The main bus interfaces on the Cortex-M3 are the code memory buses, system bus, and private peripheral bus. The code memory buses, I-Code and D-Code, are optimized for instruction fetches to enhance execution speed. The system bus provides access to memory and peripherals, including SRAM, external RAM, external devices, and system memory regions.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_13_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 13,
      "bbox": null,
      "section_title": "Bus Interfaces on Cortex-M3",
      "chunk_summary": "Details of the main bus interfaces and their functions.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 348,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_13_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_13_2"
      ],
      "created_at": "2025-11-26T10:37:39.778512"
    },
    "page_number": 13,
    "token_count": 348
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_13_2",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::13",
    "content": "The Cortex-M3 supports the Thumb-2 instruction set, which combines 32-bit and 16-bit instructions for high code density and efficiency. This feature allows flexible instruction usage, improving performance and memory utilization.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_13_2",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 13,
      "bbox": null,
      "section_title": "Instruction Set Support",
      "chunk_summary": "Description of the Thumb-2 instruction set and its advantages.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 229,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_13_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_13_3"
      ],
      "created_at": "2025-11-26T10:37:39.778512"
    },
    "page_number": 13,
    "token_count": 229
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_13_3",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::13",
    "content": "Previous ARM processors had two operation states: ARM state with 32-bit instructions and Thumb state with 16-bit instructions. ARM state offers high performance, while Thumb state provides higher code density but may require more instructions for certain operations.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_13_3",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 13,
      "bbox": null,
      "section_title": "Instruction Set States",
      "chunk_summary": "Comparison of ARM and Thumb states in previous ARM processors.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 266,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_13_2",
        "ES_Mod1@AzDOCUMENTS2.pdf_14_0"
      ],
      "created_at": "2025-11-26T10:37:39.778512"
    },
    "page_number": 13,
    "token_count": 266
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_14_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::14",
    "content": "The Cortex-M3 processor has a number of advantages over traditional ARM processors, such as:\n\n\u2022 No state switching overhead, saving both execution time and instruction space\n\n\u2022 No need to separate ARM code and Thumb code source files, making software development and maintenance easier\n\n\u2022 It\u2019s easier to get the best efficiency and performance, in turn making it easier to write software, because there is no need to worry about switching code between ARM and Thumb to try to get the best density/performance.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_14_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 14,
      "bbox": null,
      "section_title": "Embedded Systems",
      "chunk_summary": "Introduction to the Cortex-M3 processor and its advantages.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 509,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_13_3",
        "ES_Mod1@AzDOCUMENTS2.pdf_14_1"
      ],
      "created_at": "2025-11-26T10:37:41.929678"
    },
    "page_number": 14,
    "token_count": 509
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_14_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::14",
    "content": "The Cortex-M3 processor has a number of interesting and powerful instructions. Here are a few examples:\n\u2022 UFBX, BFI, and BFC: Bit field extract, insert, and clear instructions\n\n\u2022 UDIV and SDIV: Unsigned and signed divide instructions\n\n\u2022 WFE, WFI, and SEV: Wait-For-Event, Wait-For-Interrupts, and Send-Event; these allow the processor to enter sleep mode and to handle task synchronization on multiprocessor systems\n\u2022 MSR and MRS: Move to special register from general-purpose register and move special register to general-purpose register; for access to the special registers.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_14_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 14,
      "bbox": null,
      "section_title": "Cortex-M3 Instructions",
      "chunk_summary": "Overview of powerful instructions available in the Cortex-M3 processor.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 577,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_14_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_15_0"
      ],
      "created_at": "2025-11-26T10:37:41.929678"
    },
    "page_number": 14,
    "token_count": 577
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_15_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::15",
    "content": "Embedded Systems-18EC62 Azdocuments.in www.azdocuments.in Page 15",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_15_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 15,
      "bbox": null,
      "section_title": "Embedded Systems-18EC62",
      "chunk_summary": "Introduction to the page content about embedded systems and Cortex-M3 processor.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 65,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_14_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_15_1"
      ],
      "created_at": "2025-11-26T10:37:43.773581"
    },
    "page_number": 15,
    "token_count": 65
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_15_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::15",
    "content": "The Cortex-M3 processor implements a new exception model, introduced in the ARMv7-M architecture. This exception model differs from the traditional ARM exception model, enabling very efficient exception handling. It has a number of system exception handling. It has a number of system exceptions plus a number of external Interrupt Request (IRQs) (external interrupt inputs). There is no fast interrupt (FIQ) (fast interrupt in ARM7/ARM9/ ARM10/ARM11) in the Cortex-M3; however, interrupt priority handling and nested interrupt support are now included in the interrupt architecture. Therefore, it is easy to set up a system that supports nested interrupts (a higher-priority interrupt can override or preempt a lower-priority interrupt handler) and that behaves just like the FIQ in traditional ARM processors.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_15_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 15,
      "bbox": null,
      "section_title": "Interrupts and Exceptions",
      "chunk_summary": "Overview of the Cortex-M3 exception model and interrupt handling features.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 811,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_15_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_16_0"
      ],
      "created_at": "2025-11-26T10:37:43.773581"
    },
    "page_number": 15,
    "token_count": 811
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_16_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::16",
    "content": "The Cortex-M3 processor includes a number of debugging features, such as program execution controls, including halting and stepping, instruction breakpoints, data watchpoints, registers and memory accesses, profiling, and traces. The debugging hardware of the Cortex-M3 processor is based on the CoreSight\u2122 architecture.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_16_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 16,
      "bbox": null,
      "section_title": "Debugging Support",
      "chunk_summary": "Overview of debugging features in the Cortex-M3 processor.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 320,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_15_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_16_1"
      ],
      "created_at": "2025-11-26T10:37:46.629517"
    },
    "page_number": 16,
    "token_count": 320
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_16_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::16",
    "content": "Unlike traditional ARM processors, the CPU core itself does not have a Joint Test Action Group (JTAG) interface. Instead, a debug interface module is decoupled from the core, and a bus interface called the Debug Access Port (DAP) is provided at the core level. Through this bus interface, external debuggers can access control registers to debug hardware as well as system memory, even when the processor is running. The control of this bus interface is carried out by a Debug Port (DP) device.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_16_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 16,
      "bbox": null,
      "section_title": "Debug Interface Architecture",
      "chunk_summary": "Description of the debug interface architecture of Cortex-M3.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 494,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_16_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_16_2"
      ],
      "created_at": "2025-11-26T10:37:46.629517"
    },
    "page_number": 16,
    "token_count": 494
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_16_2",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::16",
    "content": "The DPs currently available are the Serial-Wire JTAG Debug Port (SWJ-DP) (supports the traditional JTAG protocol as well as the Serial-Wire protocol) or the SW-DP (supports the Serial-Wire protocol only). A JTAG-DP module from the ARM CoreSight product family can also be used. Chip manufacturers can choose to attach one of these DP modules to provide the debug interface.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_16_2",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 16,
      "bbox": null,
      "section_title": "Debug Port Modules",
      "chunk_summary": "Details of available debug port modules for Cortex-M3.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 373,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_16_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_16_3"
      ],
      "created_at": "2025-11-26T10:37:46.629517"
    },
    "page_number": 16,
    "token_count": 373
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_16_3",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::16",
    "content": "Chip manufacturers can also include an Embedded Trace Macrocell (ETM) to allow instruction trace. Trace information is output via the Trace Port Interface Unit (TPIU), and the debug host (usually a Personal Computer [PC]) can then collect the executed instruction information via external trace capturing hardware.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_16_3",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 16,
      "bbox": null,
      "section_title": "Trace Functionality",
      "chunk_summary": "Explanation of instruction trace and trace output in Cortex-M3.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 314,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_16_2",
        "ES_Mod1@AzDOCUMENTS2.pdf_17_0"
      ],
      "created_at": "2025-11-26T10:37:46.629517"
    },
    "page_number": 16,
    "token_count": 314
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_17_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::17",
    "content": "In the Cortex-M3, besides normal software-controlled stack PUSH and POP, the stack PUSH and POP operations are also carried out automatically when entering or exiting an exception/interrupt handler. In this section, we examine the software stack operations.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_17_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 17,
      "bbox": null,
      "section_title": "Embedded Systems-18EC62",
      "chunk_summary": "Introduction to stack memory operations in Cortex-M3.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 257,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_16_3",
        "ES_Mod1@AzDOCUMENTS2.pdf_17_1"
      ],
      "created_at": "2025-11-26T10:37:50.019364"
    },
    "page_number": 17,
    "token_count": 257
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_17_1",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::17",
    "content": "In general, stack operations are memory write or read operations, with the address specified by an SP. Data in registers is saved into stack memory by a PUSH operation and can be restored to registers later by a POP operation. The SP is adjusted automatically in PUSH and POP so that multiple data PUSH will not cause old stacked data to be erased.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_17_1",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 17,
      "bbox": null,
      "section_title": "Stack Operations Overview",
      "chunk_summary": "General description of stack push and pop operations.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 348,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_17_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_17_2"
      ],
      "created_at": "2025-11-26T10:37:50.019364"
    },
    "page_number": 17,
    "token_count": 348
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_17_2",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::17",
    "content": "The function of the stack is to store register contents in memory so that they can be restored later, after a processing task is completed. For normal uses, for each store (PUSH), there must be a corresponding read (POP), and the address of the POP operation should match that of the PUSH operation. When PUSH/POP instructions are used, the SP is incremented/decremented automatically.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_17_2",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 17,
      "bbox": null,
      "section_title": "Purpose of Stack",
      "chunk_summary": "Function of the stack in storing register contents.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 385,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_17_1",
        "ES_Mod1@AzDOCUMENTS2.pdf_17_3"
      ],
      "created_at": "2025-11-26T10:37:50.019364"
    },
    "page_number": 17,
    "token_count": 385
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_17_3",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::17",
    "content": "When program control returns to the main program, the R0\u2013R2 contents are the same as before. Notice the order of PUSH and POP: The POP order must be the reverse of PUSH. These operations can be simplified, thanks to PUSH and POP instructions allowing multiple load and store. In this case, the ordering of a register POP is automatically reversed by the processor.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_17_3",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 17,
      "bbox": null,
      "section_title": "Stack Operation Details",
      "chunk_summary": "Order and automatic adjustment of PUSH and POP operations.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 364,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_17_2",
        "ES_Mod1@AzDOCUMENTS2.pdf_17_4"
      ],
      "created_at": "2025-11-26T10:37:50.019364"
    },
    "page_number": 17,
    "token_count": 364
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_17_4",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::17",
    "content": "You can also combine RETURN with a POP operation. This is done by pushing the LR to the stack and popping it back to PC at the end of the subroutine.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_17_4",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 17,
      "bbox": null,
      "section_title": "Advanced Stack Usage",
      "chunk_summary": "Using PUSH and POP for subroutine return and exception handling.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 149,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_17_3",
        "ES_Mod1@AzDOCUMENTS2.pdf_18-19_0"
      ],
      "created_at": "2025-11-26T10:37:50.019364"
    },
    "page_number": 17,
    "token_count": 149
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_18-19_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::18-19",
    "content": "After the processor exits reset, it will read two words from memory. The first word at address 0x00000000 is the starting value of R13 (the SP). The second word at address 0x00000004 is the reset vector, which indicates the starting address of program execution; its least significant bit should be set to 1 to indicate Thumb state. This process differs from traditional ARM processor behavior, where program code starts from address 0x0 and the vector table contains instructions.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_18-19_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 18,
      "bbox": null,
      "section_title": "Reset Sequence",
      "chunk_summary": "Overview of the reset sequence and memory reading process in embedded systems.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 481,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_17_4",
        "ES_Mod1@AzDOCUMENTS2.pdf_18-19_2"
      ],
      "created_at": "2025-11-26T10:37:52.580585"
    },
    "page_number": 18,
    "token_count": 481
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_18-19_2",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::18-19",
    "content": "In the Cortex-M3, the initial value for the Main Stack Pointer (MSP) is placed at the beginning of the memory map, followed by the vector table containing vector address values. The vector table can be relocated during program execution. The first vector in the table is the reset vector, which is the second data fetched after reset. Since the Cortex-M3 uses a full descending stack (SP decrement before store), the initial SP value should be set to the first memory address after the top of the stack region. For example, if the stack memory range is from 0x20007C00 to 0x20007FFF (1 KB), the initial stack value should be set to 0x20008000.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_18-19_2",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 18,
      "bbox": null,
      "section_title": "Initial Stack Pointer and Program Counter Values",
      "chunk_summary": "Explanation of initial values for MSP and PC in Cortex-M3.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 643,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_18-19_0",
        "ES_Mod1@AzDOCUMENTS2.pdf_20_0"
      ],
      "created_at": "2025-11-26T10:37:52.580585"
    },
    "page_number": 18,
    "token_count": 643
  },
  {
    "id": "ES_Mod1@AzDOCUMENTS2.pdf_20_0",
    "source": "ES Mod1@AzDOCUMENTS2.pdf::20",
    "content": "Recommended Questions 1. Briefly discuss how Cortex-M3 address the requirements of the 32-bit embedded processor market 2. Briefly explain the Thumb-2 technology and its advantages over thumb instruction set with relevant diagram. 3. Write a short note on the applications of Cortex-M3 4. With a neat diagram, explain the architecture of ARM cortex M3 microcontroller. 5. What are the various registers in ARM Cortex M3? Specify the function of each of them. 6. Briefly describe the Special Register of ARM cortex M3. 7. Briefly explain about the operation modes and levels with relevant diagrams in case of ARM Cortex-M3 8. Explain the features of Nested vector Interrupt controller of ARM cortex M3. 9. With neat diagram explain the predefined memory map of ARM Cortex-M3 10. Write a short note on a) Bus interface b) Memory Protection units of ARM cortex M3. 11. Describe the interrupts and exceptions supported by ARM Cortex M3. 12. Describe the debugging support in ARM Cortex M3. 13. Explain the stack operations using PUSH and POP instructions in ARM Cortex M3. 14. With relevant diagrams explain the reset sequence in ARM cortex M3.",
    "metadata": {
      "chunk_id": "ES_Mod1@AzDOCUMENTS2.pdf_20_0",
      "source_path": "ES Mod1@AzDOCUMENTS2.pdf",
      "mime_type": "application/pdf",
      "page_number": 20,
      "bbox": null,
      "section_title": "Recommended Questions",
      "chunk_summary": "List of questions related to ARM Cortex-M3 microcontroller architecture and features.",
      "chunk_type": "text",
      "content_type": "narrative",
      "token_count": 1140,
      "vector_metric": "cosine",
      "embedding_model": "text-embedding-3-small",
      "table_schema": null,
      "neighbors": [
        "ES_Mod1@AzDOCUMENTS2.pdf_18-19_2"
      ],
      "created_at": "2025-11-26T10:37:54.629327"
    },
    "page_number": 20,
    "token_count": 1140
  }
]